---
title: Making Contour Maps in R
author: Alan Jackson
date: '2022-08-05'
slug: '[making_maps_in_r]'
categories:
  - Mapping
tags:
  - Mapping
keywords:
  - tech
comments: no
showMeta: no
showActions: no
---

```{r setup, include=FALSE}
library(tidyverse)
#library(sf)
library(leaflet)
library(leaflet.extras)

knitr::opts_chunk$set(echo = TRUE)
```

##  Notes on how to make contour maps in R

As a retired Geophysicist, I spent a career making contour maps. I have found
it to be challenging to make good contour maps in R, and so as part of my
own learning process, I have documented the necessary steps in hopes that
this may help others involved in the same struggles.

Ultimately I want to create filled contours that represent a surface, based on
some random collection of input points, and display those contours on top of
a detailed basemap, such as OpenStreet map.

I will try to use what I believe are the most recent and most likely to
survive packages wherever possible. Both static and interactive maps will be 
generated.

Note that there are several challenges that may this a somewhat difficult 
exercise.

First of all, this area of R has undergone and continues to see a fair bit
of churn. There are a number of packages that address parts of this problem,
and they tend to overlap with each other.

Secondly, there is a basic issue of coordinate systems. I will make maps in
both geographic (that is, Lat-Long) coordinates and in projected (X-Y)
coordinates. 

Third, interpolating points to a grid is partly art and partly science, so I
will give a bit of guidance there.

My test data (seen below) consists of rainfall points in the Houston area
from a selection of personal weather stations on August 19, 2022. I will
create a simple tibble, and then attach proper geodetic information while
converting it to an sf file. I will also transform the sf file to an
appropriate projected UTM coordinate system.

### Summary of process

- Create geodetically proper data in geographic and/or projected coordinates
- Preliminary work : basemap, Area of Interest
- Look at measurement point density
- Create a grid to define interpolation locations
- Build an interpolator
  - Kriging
  - Inverse weighted nearest neighbor
  - Spline fitting
- Interpolate/Predict points onto grid
- Calculate error and plot
- Generate contours
- Plot contours over a basemap

### References

There are a number of references that have been especially helpful.

[Geocomputation With R by Robin Lovelace:](https://geocompr.robinlovelace.net/index.html)

[Introduction to R Programming by Michael Dorman:](http://132.72.155.230:3838/r/index.html)

[Spatial Data Science by Edzer Pebesma and Roger Bivand:](https://keen-swartz-3146c4.netlify.app/)

[Kernel density estimates for tidy and geospatial data in the eks package:](https://cran.r-project.org/web/packages/eks/vignettes/tidysf_kde.html)


```{r make test data}

df <- tribble(
  ~Rain, ~Lat, ~Lon,  
   1.06, 29.8,  -95.4 ,
   0.27, 29.74, -95.39,
   0.15, 29.72, -95.43,
   0.32, 29.73, -95.32,
   0.75, 29.75, -95.47,
   0.56, 29.79, -95.36,
   1.72, 29.80, -95.42,
   0.49, 29.70, -95.51,
   1.3 , 29.76, -95.52,
   0.74, 29.65, -95.49,
   0.14, 29.82, -95.47,
   1.09, 29.84, -95.41,
   1.27, 29.84, -95.35,
   0.09, 29.59, -95.37,
   0   , 29.63, -95.54,
   0.66, 29.81, -95.55,
   1.1 , 29.74, -95.60,
   2.75, 29.55, -95.42,
   1.69, 29.56, -95.31,
   0.16, 29.54, -95.36,
   1.42, 29.91, -95.46,
   0.26, 29.57, -95.53,
   0.79, 29.88, -95.26,
   0.28, 29.82, -95.20,
   0.26, 29.64, -95.18,
   1.06, 29.68, -95.63,
   0.51, 29.93, -95.37,
   0.03, 29.69, -95.16,
   1.27, 29.75, -95.64,
   1.08, 29.59, -95.58,
   0.73, 29.58, -95.22,
   1.96, 29.86, -95.60,
   0.88, 29.90, -95.56,
   1.4 , 29.93, -95.28,
   0.9 , 29.53, -95.25,
   2.24, 29.95, -95.45,
   1.25, 29.82, -95.14,
   0.27, 29.54, -95.57,
   0.16, 29.64, -95.14,
   0   , 29.96, -95.50,
   0.22, 29.54, -95.21,
   1.37, 29.84, -95.67,
   0.23, 29.48, -95.31,
   1.36, 29.54, -95.61,
   0.15, 29.46, -95.37,
   1.07, 29.58, -95.66,
   1.91, 29.92, -95.16,
   1.71, 29.95, -95.20,
   1.97, 29.89, -95.66,
   0.14, 29.56, -95.13,
   0.48, 29.48, -95.22,
   1.57, 29.94, -95.63,
   2.58, 29.98, -95.60,
   0.46, 29.52, -95.67,
   1.6 , 29.48, -95.15,
   1.77, 29.99, -95.67
)

#  A few handy crs codes

googlecrs <- "EPSG:4326"
webcrs <- "EPSG:3857"
localcrs <- "EPSG:26915" # UTM 15N NAD83
localUTM <- "EPSG:32615" # a WGS84 similar to EPSG:26915 - same UTM zone

#     Locations and rainfall by lat long
df_sf <- sf::st_as_sf(df, coords=c("Lon", "Lat"), crs=googlecrs, agr = "identity")
#     Locations and rainfall by Lat Long in webcrs
df_web <- sf::st_transform(df_sf, crs=webcrs)
#     Locations and rainfall by X, Y
df_xy <- sf::st_transform(df_sf, crs=localcrs)
#     Locations and rainfall by X, Y
df_xy_2 <- sf::st_transform(df_sf, crs=localUTM)

#   Let's define a bounding box (an AOI) based on the data (in Lat-Long)

bbox <- sf::st_bbox(df_sf)

#   Expand box by 10% to give a little extra room
Dx <- (bbox[["xmax"]]-bbox[["xmin"]])*0.05
Dy <- (bbox[["ymax"]]-bbox[["ymin"]])*0.05
bbox["xmin"] <- bbox["xmin"] - Dx
bbox["xmax"] <- bbox["xmax"] + Dx
bbox["ymin"] <- bbox["ymin"] - Dy
bbox["ymax"] <- bbox["ymax"] + Dy

bb <- c(bbox["xmin"], bbox["ymin"], bbox["xmax"], bbox["ymax"])

```


### Basemaps

My goal is to use the OpenStreet Map as a basemap. Retrieving those tiles
will result in an image file in the so-called web crs,
EPSG:3857, the Spherical Pseudo-Mercator projection. Being pixels, including
the text, the image itself cannot be easily reprojected, so to use that image
we will have to make sure everything is in EPSG:3857.

There are several packages that will download OSM tiles.

- OpenStreetMap: Last update a few years ago 
- basemaps: appears to be an active project
- osmdata: Pulls vector data - different beast
- basemapR: active project, not on CRAN
- ggspatial: active project, on CRAN

Interestingly, OpenStreetMap, basemaps, and ggspatial make crappy looking maps, fuzzy
and not pleasing - cluttered with odd stuff. The basemapR map is much more
aesthetically pleasing.

I don't understand what OpenStreetMap is actually doing when it "reprojects"
the basemap. And it seems to be broken. Without reprojecting, the map appears
to be in an X-Y system, but a strange one. I can reproject to a lat long
system and everything seems okay, but if I give it an X-Y system to reproject
to, it ends up in lat-long. At least according to the axis values. 
Apparently OpenStreetMap uses the raster package to do projections. The following
warning is in the raster::projectRaster docs, "User beware. Sadly, the PROJ.4 notation 
has been partly deprecated in the GDAL/PROJ library that is used by this function. 
You can still use it, but *only* with the the WGS84 datum. Other datums are silently 
ignored." which explains a lot. Which is a serious limitation. Many states and counties
in the US do not use WGS84, but use NAD83 - which is close, but leads to a different
set of EPSG codes, and is a trap for the unwary. I really hate "silently ignores". That
is aggressively user unfriendly.

Using osmdata is a lot more work, and the map is much plainer (unless you
expend significant effort adding and controlling features), but it does
make a pretty good looking map.

As far as I can tell, the only package that will allow for a projected basemap
(that is X-Y coordinates) is OpenStreetMap. Which is sad.

There is also quite a bit of disparity in the size of the map objects. 

```{r size table, echo-=FALSE, results='asis'}
Basemap_size <- tribble( ~Package, ~Size_KB,
                         "OpenStreetMap", 6600,
                         "basemaps", 4.7,
                         "basemapR", 4.4,
                         "ggspatial", 34.0)
knitr::kable(Basemap_size, caption="Sizes in KB for different map objects")

```


```{r basemaps, warning=FALSE, message=FALSE}

########  package: OpenStreetMap
# Produces an OpenStreetMap object
Basemap_1 <- OpenStreetMap::openmap(c(bbox[["ymin"]],
                                    bbox[["xmin"]]),
                                  c(bbox[["ymax"]],
                                    bbox[["xmax"]]),
                                  type="osm")

########  package: basemaps
# Produces a ggplot object
basemaps::set_defaults(map_service = "osm", map_type = "streets")
Basemap_2 <- basemaps::basemap_ggplot(ext=bbox)

########  package: basemapR
# Produces a ggplot object
Basemap_3 <- basemapR::base_map(bbox, basemap="mapnik", increase_zoom=2)

########  package: ggspatial
# Produces a ggplot object
Basemap_4 <- ggplot(df_sf) + ggspatial::annotation_map_tile(zoomin=-1) 

# ---------------------   Let's plot the maps, with some data if possible

#   Plot in projected coordinates, but be careful!
m1 <- OpenStreetMap::autoplot.OpenStreetMap(OpenStreetMap::openproj(Basemap_1,
                                      projection=localcrs)) +
  geom_point(data=as_tibble(sf::st_coordinates(df_xy)), aes(x=X, y=Y))
#   Plot in Lat Long (Scale coordinates to act like lat-long )
m2 <- OpenStreetMap::autoplot.OpenStreetMap(OpenStreetMap::openproj(Basemap_1),
                                      projection=googlecrs) +
  geom_point(data=df, aes(y=Lat, x=Lon))
  
m3 <- Basemap_2 +
  geom_sf(data=df_web)
  
#   This is the best looking one.
m4 <- df_sf %>% ggplot() +
  Basemap_3 +
  geom_sf()

m5 <- Basemap_4 +
    geom_sf(inherit.aes = FALSE) +
    theme_minimal()

#gridExtra::grid.arrange(m1, m2, m3, m4, m5, ncol=2)

m1
m2
m3
m4
m5

```

###  One more basemap, but this one built with vectors, not rasters

The data from the Open Street Maps can be downloaded as points, vectors, and polygons.
This allows a scale-free map of much higher resolution, but is not quite as nice,
unless a lot of effort is expended on the aesthetics, and is also quite large. Actually
the various vector layers can be quite large, but the final map is quite small, as can
be seen in the table below. 

For plotting the map in projected coordinates, we have to project the AOI as well. But we
can plot the map in projected coordinates which most of the raster-based basemaps do not
allow. So there are some clear advantages to using a vector map. Probably not what you want
for a quick and dirty, but if you plane to be working in the same area for some time, it is
probably worth spending the effort to tweak up a pretty vector-based map.

```{r size table, echo-=FALSE, results='asis'}
Basemap_size <- tribble( ~Package, ~Size_KB,
                         "Big Streets", 47.4,
                         "Medium Streets", 99.0,
                         "Rivers", 35.4,
                         "Lakes", 45.9,
                         "ggplot object", 5.7)
knitr::kable(Basemap_size, caption="Sizes in KB for different map objects")
```


```{r basemaps_2, warning=FALSE, message=FALSE}

###########   Now for something different, let's create a map with vectors
###########   by using osmdata 

osmdata::available_features()
osmdata::available_tags("highway")


#     pull out the "big streets"
big_streets <- 
  tmaptools::bb(bbox, output="matrix") %>% # turn bounding box into matrix
  osmdata::opq()%>% # Build query
  osmdata::add_osm_feature(key = "highway", 
                  value = c("motorway", 
                            "motorway_link" 
                            )) %>% # select the big roads
  osmdata::osmdata_sf() # turn into an sf file
  

#     pull out the "medium streets"
med_streets <- 
  tmaptools::bb(bbox, output="matrix") %>%  # turn bounding box into matrix
  osmdata::opq()%>%  #   Build query
  osmdata::add_osm_feature(key = "highway", 
                  value = c( "secondary_link",
                            "secondary")) %>%  #   Grab smaller roads
  osmdata::osmdata_sf() #   Make sf

#   Now get rivers
osmdata::available_tags("waterway")
osmdata::available_tags("water")

river <- tmaptools::bb(bbox, output="matrix") %>%
  osmdata::opq()%>%
  osmdata::add_osm_feature(key = "waterway", value = "river") %>%
  osmdata::osmdata_sf()  

lakes <- tmaptools::bb(bbox, output="matrix") %>%
  osmdata::opq()%>%
  osmdata::add_osm_feature(key = "water", value = c("reservoir",
                                                    "lake",
                                                    "basin",
                                                    "pond")) %>%
  osmdata::osmdata_sf() 

#   Now put it all together and make a plot

m6 <- ggplot() +
  geom_sf(data = med_streets$osm_lines,
          inherit.aes = FALSE,
          size = 0.4,
          color = "grey25") +
  geom_sf(data = big_streets$osm_lines,
          inherit.aes = FALSE,
          size = 0.4,
          color = "red") +
  geom_sf(data = river$osm_lines,
          inherit.aes = FALSE,
          size = 0.4,
          color = "blue") +
  geom_sf(data = lakes$osm_polygons,
          inherit.aes = FALSE,
          fill="steelblue",
          color = "steelblue") +
  geom_sf(data=df_sf) +
  #   coord_sf needs to follow all the geom_sf statements
  coord_sf(xlim = c(bbox[["xmin"]], bbox[["xmax"]]),
           ylim = c(bbox[["ymin"]], bbox[["ymax"]]),
           expand = FALSE,
           default_crs=googlecrs)  

m6

#   Convert to X-Y for a projected map

#  First convert bounding box (I need to make this cleaner, but this will do for now)

XYmin <- sf::st_transform(sf::st_sfc(sf::st_point(x=c(bbox[["xmin"]], bbox[["ymin"]])),
                                     crs=googlecrs), crs=localcrs)
XYmax <- sf::st_transform(sf::st_sfc(sf::st_point(x=c(bbox[["xmax"]], bbox[["ymax"]])),
                                     crs=googlecrs), crs=localcrs)

m7 <- ggplot(df_xy) +
  geom_sf(data = sf::st_transform(med_streets$osm_lines, crs=localcrs),
          inherit.aes = FALSE,
          size = 0.4,
          color = "grey25") +
  geom_sf(data = sf::st_transform(big_streets$osm_lines, crs=localcrs),
          inherit.aes = FALSE,
          size = 0.4,
          color = "red") +
  geom_sf(data = sf::st_transform(river$osm_lines, crs=localcrs),
          inherit.aes = FALSE,
          size = 0.4,
          color = "blue") +
  geom_sf(data = sf::st_transform(lakes$osm_polygons, crs=localcrs),
          inherit.aes = FALSE,
          fill="steelblue",
          color = "steelblue") +
  geom_sf(data=df_xy) + # This will post graticules in X-Y rather than Lat-Long
  # coord_sf must follow the geom_sf statements for the bounding box to be applied properly
  coord_sf(xlim = c(XYmin[[1]][1], XYmax[[1]][1]),
           ylim = c(XYmin[[1]][2], XYmax[[1]][2]),
           expand = FALSE,
           datum=localcrs,
           default_crs=localcrs)

m7

```

### Interactive maps

Now we will create basemaps with input points as interactive maps using both Leaflet and tmap.

I like Leaflet, but it does seem to me to be a bit limited. What it does, it does well 
and simply. I have foregone the default markers because I don't really like them, and so 
that this map is more comparable to the other maps.

Note that the basemap quality is quite high - the features and lettering are crisp and 
distinct - something that the static basemaps seem to struggle with. There is a plugin
for Leaflet that allows the use of projected data - but *only if the server uses that same
projection*. So, for the general case of projecting to a local system, it is pretty useless
unless you actually set up your own server for your area of interest.

```{r leaflet basemap}

leaflet::leaflet() %>% 
  leaflet::addTiles() %>% # OpenStreetMap by default
  leaflet::addCircleMarkers(data=df_sf, 
                   radius=2, 
                   color="black",
                   opacity=1,
                   fillOpacity = 1)

```

Finally let's take a look at tmap - which can do both static and interactive maps.

We can also transform the basemap to a local X-Y coordinate system, but the results are
not especially pleasing since the text labels get distorted by the transform.

```{r tmap basemap}

tmap::tmap_mode("view") # set mode to interactive plots

tmap::tm_shape(df_sf) + 
  tmap::tm_sf(col="black", size=0.5)

#  Note that you need to interactively pick which basemap to display

#  Now make a static map

tmap::tmap_mode("plot") # set mode to static plots

Basemap_5 <- tmaptools::read_osm(bbox, type="osm")

# bbox_sf <- sf::st_sfc(sf::st_multipoint(x=tmaptools::bb(bbox, output="matrix", 
#                                              current.projection = googlecrs)))
# sf::st_crs(bbox_sf) <- googlecrs

tmap::tm_shape(Basemap_5) +
    tmap::tm_rgb() +
tmap::tm_shape(df_sf) + 
  tmap::tm_sf(col="black", size=0.3)

#     And now for projected coordinates

Basemap_6 <- stars::st_transform_proj(Basemap_5, crs=localcrs)

tmap::tm_shape(Basemap_6) +
    tmap::tm_rgb() +
tmap::tm_shape(df_xy) + 
  tmap::tm_sf(col="black", size=0.3)


```


###   Density contours

We will ignore the actual point values and just look at the point density.
This is generally a good idea, just to get a feel for where the data is thin 
and where the ending results are likely to be more reliable. And this will be 
a good way to work through the mechanics of posting filled contours onto a
basemap.

Let's plot three ways, an interactive plot with Leaflet, and a static plot with
ggplot, and also use tmap.

For the static maps, I will use the basemaps generated above that looked the best.

To add a scalebar, there are two options: ggspatial or ggsn. 

References that were especially helpful :

https://swilke-geoscience.net/post/spatial_interpolation/
https://github.com/dkahle/ggmap
https://r-spatial.org/r/2018/10/25/ggplot2-sf.html
###       Measurement density

Let's make a quick plot of the measurement location density. Always nice to
get a feel for where the measurements are denser. My biggest issue with the 
density plot is that I don't know what the numbers mean. A density of 5 is
5 stations per what? Not at all clear. Of course, it is fairly bogus anyway
since I have done everything in Lat-Long, and not in X-Y.

Static map in ggplot, and lets make interactive maps in tmap and leaflet.

Note, I just discovered the package [eks](https://www.mvstat.net/mvksa/), 
which is built for kernel smoothing in the tidyverse and with sf.


```{r point maps in ggplot}

#   Prepare a scalebar to be used in all maps following

gsc <- ggspatial::annotation_scale(data=df_xy, 
   location="br", width_hint=0.2, bar_cols=1)

#   First we plot maps with ggplot, or the wrapper OpenStreetMap

# Plot the input point locations

df_sf %>% ggplot() + 
  geom_sf()

OpenStreetMap::autoplot.OpenStreetMap(Basemap2) +
  geom_point(data=df, aes(x=Lon, y=Lat))

df_sf %>% ggplot() +
  Basemap_3 +
  geom_sf()

##########################################################
#   Density map
##########################################################

#   Lay down basemap
ggplot() +
  #   this is the best looking basemap
  Basemap_3 +
  #   Add points
  geom_point(data=df, aes(x=Lon, y=Lat)) +
  #   Create filled density "contours" - the as.numeric converts from factor
  #   for the scale_fill_gradient command.
  stat_density_2d_filled(data=df, 
                         alpha = 0.4, 
                         n=50,
                         contour_var="density",
                         aes(x=Lon, y=Lat, 
                             fill=as.numeric(..level..))) +
  #   Add actual contour lines
  stat_density_2d(data=df, 
                  alpha = 0.8, 
                  n=50,
                  contour=TRUE,
                  contour_var="density",
                  aes(x=Lon, y=Lat )) +
  #   Twiddle the color scale
  scale_fill_gradient2("Rainfall Station\ndensity", 
                       low = "white", 
                       mid = "yellow", 
                       high = "red", 
                       limits=c(0,8),
                       midpoint = 4) +
  #   Add a scale bar
  gsc +
  #ggsn::scalebar(df_sf, dist = 2, dist_unit = "mi", location="bottomleft",
  #           transform = TRUE, model = "WGS84") +
  #   Add title
  ggtitle("Density of Rainfall Measurements") +
  #   Remove lat/long tics and labels as unnecessary
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank()
        ) +
  #   The Lat Long labels are distracting and unnecessary
    labs(x="", y="")

#######  Just for fun let's utilize the eks package for density estimates

Sta_den <- eks::st_kde(df_sf) # calculate density

xlim <- c()
#   Lay down basemap
ggplot() +
  #   this is the best looking basemap
  Basemap_3 +
  #   Add points
  geom_sf(data=df_sf) +
  #   Create filled density "contours" 
  geom_sf(data=eks::st_get_contour(Sta_den,
                                   cont=c(20,40,60,80)),   
          aes(fill=eks::label_percent(contlabel)), alpha=0.4) +
  colorspace::scale_fill_discrete_sequential(name = "Density Percentile") +

  #   Add a scale bar
  ggsn::scalebar(df_sf, dist = 2, dist_unit = "mi", location="bottomleft",
             transform = TRUE, model = "WGS84") +
  #   Add title
  ggtitle("Density of Rainfall Measurements") +
  #   Remove lat/long tics and labels as unnecessary
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank()
        ) +
  #   The Lat Long labels are distracting and unnecessary
    labs(x="", y="") +
  coord_sf(xlim = c(bbox[["xmin"]], bbox[["xmax"]]),
           ylim = c(bbox[["ymin"]], bbox[["ymax"]]),
           expand = FALSE,
           default_crs=googlecrs) #+
  #ggthemes::theme_map()

############    Now let's do it in Leaflet

leaflet() %>% 
  addTiles() %>% # OpenStreetMap by default
  addCircleMarkers(data=df_sf, 
                   radius=2, 
                   color="black",
                   opacity=1,
                   fillOpacity = 1) %>% 
  #   This is *not* the same as stat_density, and is scale dependent, 
  #   which sucks.
  addHeatmap(data=df, group="heat", max=.6, blur = 60,
             radius=30)
  
# So let's try somethihg different. 
#  (http://technocyclist.blogspot.com/2014/10/plot-contour-polygons-in-leaflet-using-r.html) 

#   Create a density map, and display contours
d2d = KernSmooth::bkde2D(cbind(df$Lon,df$Lat),bandwidth=c(0.0225,0.0225))
contour(d2d$x1,d2d$x2,d2d$fhat)

# Create linestrings
lines = contourLines(x=d2d$x1, y=d2d$x2, z=d2d$fhat, nlevels = 8)

# Create independent polygons within a list
dd1 = sapply(1:length(lines), function(i) sp::Polygon(as.matrix(cbind(lines[[i]]$x,lines[[i]]$y))))
#dd1 = sapply(1:length(lines), function(i) sf::st_polygon( list(cbind(lines[[i]]$x, lines[[i]]$y)))) 

# Merge all independent polygons into a Polygons object (this contains multiple polygons)
dd2 = sapply(1:length(lines),function(i) sp::Polygons(list(dd1[[i]]),i))
##dd2 <- sf::st_multipolygon(dd1)

# Don't forget to remember the contour value for each polygon - we store it into a dataframe for use in the next step
poly_data = data.frame(Value = sapply(1:length(lines),function(i) lines[[i]]$level))

# Merge the Polygons object dd2 with the dataframe containing the contour level data, poly_data.
dd3 = sp::SpatialPolygonsDataFrame(sp::SpatialPolygons(dd2),data = poly_data) 

# Convert our dd3 SpatialPolygonDataFrame object to JSON
###dd_json = toGeoJSON(dd3,name="Rainfall")
dd_json = geojsonio::geojson_json(dd3,name="Rainfall")

# Store the unique levels of the contours, this will come in handy for colouring
values = unique(sapply(1:length(lines),function(i) lines[[i]]$level)) 
#sty = styleCat(prop="Value",val=values,style.val=brewer.pal(length(values),"Greens"),leg = "Tree Cover")

leaflet(dd_json) %>% 
  addTiles() %>% # OpenStreetMap by default
  addCircleMarkers(data=df_sf, 
                   radius=2, 
                   color="black",
                   opacity=1,
                   fillOpacity = 1)  %>% 
  addGeoJSON(dd_json)

```


##        Contours by value

This is complicated. Because we want a basemap underneath, the basemap is in 
EPSG:3857, the Spherical Pseudo-Mercator projection, and is
basically just an image.

But gridding schemes want to be in X-Y.

So let's set up a lat-long grid, convert to X-Y, interpolate to the X-Y locations, and
then put those back on the lat-long grid.


```{r heat maps by value}


##########################################################
#   Heat map by value
##########################################################

#   This is more complex. We first have to create a grid, then
#   interpolate to that grid. Then we can contour the grid.

####   Create a grid to interpolate to

df_grid <- df_sf_pan %>% 
  st_bbox() %>% 
  st_as_sfc() %>% 
  st_make_grid(
  cellsize = c(.01, .01), # degrees
  what = "centers"
  ) %>%
  st_as_sf() %>%
  cbind(., st_coordinates(.)) %>% 
  st_drop_geometry() %>% 
  mutate(Z = 0)

#   Also create a raster of the grid for some of the algorithms

df_grid_raster <- df_grid %>% 
  raster::rasterFromXYZ(
     crs = googlecrs
  )

#   Now fit various models to the data

#   -------- Nearest Neighbor
fit_NN <- gstat::gstat( # using package {gstat} 
  formula = Num_panels ~ 1,    
  data = as(df_sf_pan, "Spatial"), # using {sf} and converting to {sp}
  nmax = 10, nmin = 3 # Number of neighboring observations used for the fit
)

# -------- Inverse Distance Weighting
fit_IDW <- gstat::gstat( # The setup here is quite similar to NN
  formula = Num_panels ~ 1,
  data = as(df_sf_pan, "Spatial"), # using {sf} and converting to {sp}
  nmax = 10, nmin = 3,
  set = list(idp = 0.5) # inverse distance power
)

interp_IDW <- raster::interpolate(df_grid_raster, fit_IDW)

# -------- Thin Plate Spline Regression
fit_TPS <- fields::Tps( # using {fields}
  x = as.matrix(df_panels[, c("Lon", "Lat")]), # accepts points but expects them as matrix
  Y = df_panels$Num_panels,  # the dependent variable
  miles = FALSE     # EPSG 25833 is based in meters
)

# --------- Generalized Additive Model
#fit_GAM <- mgcv::gam( # using {mgcv}
#  Num_panels ~ s(Lon, Lat),      # here come our X/Y/Z data - straightforward enough
#  data = df_panels      # specify in which object the data is stored
#)

# --------- Automatized Kriging  
fit_KRIG <- automap::autoKrige(      # using {automap}
  formula = Num_panels ~ 1,         # The interface is similar to {gstat} but
  input_data = as(df_xy_pan, "Spatial") # {automap} makes a lot of assumptions for you
) %>% 
  .$krige_output %>%  # the function returns a complex object with lot's of metainfo
  as.data.frame() %>% # we keep only the data we are interested in
  dplyr::select(X = x1, Y = x2, Z = var1.pred) 
interp_KRIG <- raster::rasterFromXYZ(fit_KRIG, crs = googlecrs)
# Convert grid to a lat-long tibble of points
df_krig <- raster::rasterToPoints(interp_KRIG) %>% 
  as_tibble() %>% 
  st_as_sf(., coords=c("x", "y"), crs=26915, agr = "identity") %>% 
  st_transform(., crs=googlecrs) %>% 
     mutate(Lon = unlist(map(geometry,1)),
            Lat = unlist(map(geometry,2))) %>% 
  st_drop_geometry()
#   Lat long raster
df_grid_raster_sp <- sp::SpatialPoints(df_grid_raster)
fitmax <- gstat::gstat(formula = Z ~ 1, data = df_krig, nmax = 4, set = list(idp = .5))
maxint <- raster::interpolate(object=df_grid_raster_sp, model=fitmax)

wgs84 = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
df_krig_ll = raster::projectRaster(from=df_krig, to=df_grid_raster,
                                   crs = googlecrs, method = "bilinear")
#df_krig_ll <- raster::projectRaster(interp_KRIG, crs = googlecrs)
#df_krig_ll <- raster::rasterToPolygons(df_krig_ll)
#' Transform raster as data.frame to be later used with ggplot
#' Modified from rasterVis::gplot
#'
#' @param x A Raster* object
#' @param maxpixels Maximum number of pixels to use
#'
#' @details rasterVis::gplot is nice to plot a raster in a ggplot but
#' if you want to plot different rasters on the same plot, you are stuck.
#' If you want to add other information or transform your raster as a
#' category raster, you can not do it. With `SDMSelect::gplot_data`, you retrieve your
#' raster as a data.frame that can be modified as wanted using `dplyr` and
#' then plot in `ggplot` using `geom_tile`.
#' If Raster has levels, they will be joined to the final tibble.
#'
#' @export

gplot_data <- function(x, maxpixels = 50000)  {
  x <- raster::sampleRegular(x, maxpixels, asRaster = TRUE)
  coords <- raster::xyFromCell(x, seq_len(raster::ncell(x)))
  ## Extract values
  dat <- utils::stack(as.data.frame(raster::getValues(x)))
  names(dat) <- c('value', 'variable')

  dat <- dplyr::as.tbl(data.frame(coords, dat))

  if (!is.null(levels(x))) {
    dat <- dplyr::left_join(dat, levels(x)[[1]],
                            by = c("value" = "ID"))
  }
  dat
}

#   Lay down basemap
OpenStreetMap::autoplot.OpenStreetMap(Basemap2) +
#  ggplot()+
  #geom_polygon(data=df_krig_ll, aes(fill=rep(df_krig_ll$data, each = 5)), alpha=0.8) 
  #geom_tile(data=gplot_data(interp_KRIG), aes(x,y,fill=value), alpha=0.5)
  geom_tile(data=gplot_data(interp_IDW), aes(x,y,fill=value), alpha=0.5)+
  viridis::scale_fill_viridis() +
  #   Add actual contour lines
  geom_contour(data=gplot_data(interp_IDW), 
                   aes(x,y, z=value),
                   alpha = 0.8, 
                   #binwidth=1.60934,
                   binwidth=2
   )
  #   Twiddle the color scale
  scale_fill_gradient2("Solar Panels\nper sq-mi", 
                       low = "white", 
                       mid = "yellow", 
                       high = "red", 
                       #limits=c(2,50),
                       #midpoint =  5
                       ) +
  #   Add a scale bar
  scalebar(df_sf, dist = 2, dist_unit = "mi", location="bottomleft",
             transform = TRUE, model = "WGS84") +
  #   Add title
  ggtitle("Number of Solar Panels per sq-mi") +
  #   Remove lat/long tics and labels as unnecessary
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank()
        ) +
  labs(x="", y="")


# --------------  function for plotting a raster

plot_raster <- function(raster) {
  df <- raster::rasterToPoints(raster) %>% as_tibble()
  colnames(df) <- c("X", "Y", "Z")
  
  ggplot(df, aes(x=X, y=Y, z=Z, fill=Z)) +
  #OpenStreetMap::autoplot.OpenStreetMap(Basemap2) +
    geom_point(data=df, aes(x=X, y=Y)) +
    geom_raster(data=df, aes(x=X, y=Y, z=Z, fill=Z)) #+
    #scale_fill_viridis(option="C")
}

plot_raster(interp_KRIG)

##################################   stopped here
#   Lay down basemap
#OpenStreetMap::autoplot.OpenStreetMap(Basemap2) +
  #   Add points
ggplot(data=df_panels)+
  geom_point(data=df_panels, aes(x=Lon, y=Lat)) +
  #   Create filled density "contours" - the as.numeric converts from factor for
  #   the scale_fill_gradient command.
  # geom_contour_filled(data=df_panels, 
  #                     alpha = 0.4, 
  #                     #binwidth=1.60934, # native units are kilometers, 
  #                     #                   so convert to miles
  #                     aes(x=Lon, y=Lat, z=Num_panels)) +
  #   Add actual contour lines
  geom_contour(data=df_panels, 
               alpha = 0.8, 
               #binwidth=1.60934,
               aes(x=Lon, y=Lat, z=Num_panels ))# +
  #   Twiddle the color scale
  scale_fill_gradient2("Solar Panels\nper sq-mi", 
                       low = "white", 
                       mid = "yellow", 
                       high = "red", 
                       limits=c(2,12),
                       midpoint =  5) +
  #   Add a scale bar
  scalebar(df_sf, dist = 2, dist_unit = "mi", location="bottomleft",
             transform = TRUE, model = "WGS84") +
  #   Add title
  ggtitle("Number of Solar Panels per sq-mi") +
  #   Remove lat/long tics and labels as unnecessary
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank()
        ) +
  labs(x="", y="")

  
ggplot(data=df_panels, aes(Lon, Lat, z=Num_panels, color=Num_panels))+
  scale_color_gradientn(colors = c("blue", "yellow", "red")) +
  geom_point() +
  geom_contour()
```


```{r cleaner grid and plot}
coord_sf(xlim = st_coordinates(bbox_new)[c(1,2),1], # min & max of x values
           ylim = st_coordinates(bbox_new)[c(2,3),2]) + # min & max of y values
  
  coord_sf(
    xlim = c(bbox["xmin"], bbox["xmax"]),
    ylim = c(bbox["ymin"], bbox["ymax"]), crs = 4326
  )
#   Create a bounding box and use for basemap

bbox <- sf::st_bbox(df_sf)
Basemap <- OpenStreetMap::openmap(c(bbox$ymin[[1]],
                                    bbox$xmin[[1]]),
                                  c(bbox$ymax[[1]],
                                    bbox$xmax[[1]]),
                                  type="osm")
Basemap2 <- OpenStreetMap::openproj(Basemap)
OpenStreetMap::autoplot.OpenStreetMap(Basemap2)

#   Create a lat long grid

####   Create a grid to interpolate to

df_grid <- df_sf_pan %>% 
  st_bbox() %>% 
  st_as_sfc() %>% 
  st_make_grid(
  cellsize = c(.01, .01), # degrees
  what = "centers"
  ) %>%
  st_as_sf() %>%
  cbind(., st_coordinates(.)) %>% 
  st_drop_geometry() %>% 
  mutate(Z = 0)

#   Also create a raster of the grid for some of the algorithms

df_grid_raster <- df_grid %>% 
  raster::rasterFromXYZ(
     crs = googlecrs
  )

# -------- Inverse Distance Weighting
fit_IDW <- gstat::gstat( # The setup here is quite similar to NN
  formula = Num_panels ~ 1,
  data = as(df_sf_pan, "Spatial"), # using {sf} and converting to {sp}
  nmax = 10, nmin = 2,
  set = list(idp = 0.5) # inverse distance power
)

#   Apply model to grid to create predicted points
interp_IDW <- raster::interpolate(df_grid_raster, fit_IDW)

#   Smooth the result for esthetics
interp_IDW_sm <- raster::focal(interp_IDW, w=matrix(1, 3, 3), mean, pad=TRUE)

#   Lay down basemap
OpenStreetMap::autoplot.OpenStreetMap(Basemap2) +
  geom_tile(data=gplot_data(interp_IDW_sm), aes(x,y,fill=value), alpha=0.3)+
  viridis::scale_fill_viridis() +
  #   Add actual contour lines
  geom_contour(data=gplot_data(interp_IDW_sm), 
                   aes(x,y, z=value),
                   alpha = 0.8, 
                   binwidth=3) +
  geom_point(data=df_panels, aes(x=Lon, y=Lat, color=Num_panels)) 
  
  
  
```





