---
title: Making Contour Maps in R
author: Alan Jackson
date: '2022-08-05'
slug: '[making_maps_in_r]'
categories:
  - Mapping
tags:
  - Mapping
keywords:
  - tech
comments: no
showMeta: no
showActions: no
---

```{r setup, include=FALSE}
library(tidyverse)
#library(sf)
library(leaflet)
library(leaflet.extras)

knitr::opts_chunk$set(echo = TRUE)
```

##  Notes on how to make contour maps in R

As a retired Geophysicist, I spent a career making contour maps. I have found
it to be challenging to make good contour maps in R, and so as part of my
own learning process, I have documented the necessary steps in hopes that
this may help others involved in the same struggles.

Ultimately I want to create filled contours that represent a surface, based on
some random collection of input points, and display those contours on top of
a detailed basemap, such as OpenStreet map.

I will try to use what I believe are the most recent and most likely to
survive packages wherever possible. Both static and interactive maps will be 
generated.

Note that there are several challenges that may this a somewhat difficult 
exercise.

First of all, this area of R has undergone and continues to see a fair bit
of churn. There are a number of packages that address parts of this problem,
and they tend to overlap with each other.

Secondly, there is a basic issue of coordinate systems. I will make maps in
both geographic (that is, Lat-Long) coordinates and in projected (X-Y)
coordinates. 

Third, interpolating points to a grid is partly art and partly science, so I
will give a bit of guidance there.

My test data (seen below) consists of rainfall points in the Houston area
from a selection of personal weather stations on August 19, 2022. I will
create a simple tibble, and then attach proper geodetic information while
converting it to an sf file. I will also transform the sf file to an
appropriate projected UTM coordinate system.

### Summary of process

- Create geodetically proper data in geographic and/or projected coordinates
- Preliminary work : basemap, Area of Interest
- Plot contours of measurement point density
- Create a grid to define interpolation locations
- Build an interpolator
  - Kriging
  - Inverse weighted nearest neighbor
  - Spline fitting
- Interpolate/Predict points onto grid
- Calculate error and plot
- Generate contours
- Plot contours over a basemap

### References

There are a number of references that have been especially helpful.

[Geocomputation With R by Robin Lovelace: ](https://geocompr.robinlovelace.net/index.html)

[Introduction to R Programming by Michael Dorman: ](http://132.72.155.230:3838/r/index.html)

[Spatial Data Science by Edzer Pebesma and Roger Bivand: ](https://keen-swartz-3146c4.netlify.app/)

[Kernel density estimates for tidy and geospatial data in the eks package:](https://cran.r-project.org/web/packages/eks/vignettes/tidysf_kde.html)

[Data Analysis and Visualization with R: Spatial: ](http://www.geo.hunter.cuny.edu/~ssun/R-Spatial/mapping.html#web-mapping-with-leaflet)

[smoothr - package for smoothing contours: ](https://cran.r-project.org/web/packages/smoothr/vignettes/smoothr.html)

[basemapR - package for creating a basemap: ](https://github.com/Chrisjb/basemapR)

[Intro to GIS and Spatial Analysis by Manuel Gimond: ](https://mgimond.github.io/Spatial/interpolation-in-r.html)

```{r make test data}

df <- tribble(
  ~Rain, ~Lat, ~Lon,  
   1.06, 29.8,  -95.4 ,
   0.27, 29.74, -95.39,
   0.15, 29.72, -95.43,
   0.32, 29.73, -95.32,
   0.75, 29.75, -95.47,
   0.56, 29.79, -95.36,
   1.72, 29.80, -95.42,
   0.49, 29.70, -95.51,
   1.3 , 29.76, -95.52,
   0.74, 29.65, -95.49,
   0.14, 29.82, -95.47,
   1.09, 29.84, -95.41,
   1.27, 29.84, -95.35,
   0.09, 29.59, -95.37,
   0   , 29.63, -95.54,
   0.66, 29.81, -95.55,
   1.1 , 29.74, -95.60,
   2.75, 29.55, -95.42,
   1.69, 29.56, -95.31,
   0.16, 29.54, -95.36,
   1.42, 29.91, -95.46,
   0.26, 29.57, -95.53,
   0.79, 29.88, -95.26,
   0.28, 29.82, -95.20,
   0.26, 29.64, -95.18,
   1.06, 29.68, -95.63,
   0.51, 29.93, -95.37,
   0.03, 29.69, -95.16,
   1.27, 29.75, -95.64,
   1.08, 29.59, -95.58,
   0.73, 29.58, -95.22,
   1.96, 29.86, -95.60,
   0.88, 29.90, -95.56,
   1.4 , 29.93, -95.28,
   0.9 , 29.53, -95.25,
   2.24, 29.95, -95.45,
   1.25, 29.82, -95.14,
   0.27, 29.54, -95.57,
   0.16, 29.64, -95.14,
   0   , 29.96, -95.50,
   0.22, 29.54, -95.21,
   1.37, 29.84, -95.67,
   0.23, 29.48, -95.31,
   1.36, 29.54, -95.61,
   0.15, 29.46, -95.37,
   1.07, 29.58, -95.66,
   1.91, 29.92, -95.16,
   1.71, 29.95, -95.20,
   1.97, 29.89, -95.66,
   0.14, 29.56, -95.13,
   0.48, 29.48, -95.22,
   1.57, 29.94, -95.63,
   2.58, 29.98, -95.60,
   0.46, 29.52, -95.67,
   1.6 , 29.48, -95.15,
   1.77, 29.99, -95.67
)

#  A few handy crs codes

googlecrs <- "EPSG:4326"
webcrs <- "EPSG:3857"
localcrs <- "EPSG:26915" # UTM 15N NAD83
localUTM <- "EPSG:32615" # a WGS84 similar to EPSG:26915 - same UTM zone

#     Locations and rainfall by lat long
df_sf <- sf::st_as_sf(df, coords=c("Lon", "Lat"), crs=googlecrs, agr = "identity")
#     Locations and rainfall by Lat Long in webcrs
df_web <- sf::st_transform(df_sf, crs=webcrs)
#     Locations and rainfall by X, Y
df_xy <- sf::st_transform(df_sf, crs=localcrs)
#     Locations and rainfall by X, Y
df_xy_2 <- sf::st_transform(df_sf, crs=localUTM)

#   Let's define a bounding box (an AOI) based on the data (in Lat-Long)

bbox <- sf::st_bbox(df_sf)

#   Expand box by 20% to give a little extra room
Dx <- (bbox[["xmax"]]-bbox[["xmin"]])*0.1
Dy <- (bbox[["ymax"]]-bbox[["ymin"]])*0.1
bbox["xmin"] <- bbox["xmin"] - Dx
bbox["xmax"] <- bbox["xmax"] + Dx
bbox["ymin"] <- bbox["ymin"] - Dy
bbox["ymax"] <- bbox["ymax"] + Dy

bb <- c(bbox["xmin"], bbox["ymin"], bbox["xmax"], bbox["ymax"])

```


### Basemaps

My goal is to use the OpenStreet Map as a basemap. Retrieving those tiles
will result in an image file in the so-called web crs,
EPSG:3857, the Spherical Pseudo-Mercator projection. Being pixels, including
the text, the image itself cannot be easily reprojected, so to use that image
we will have to make sure everything is in EPSG:3857.

There are several packages that will download OSM tiles.

- OpenStreetMap: Last update a few years ago 
- basemaps: appears to be an active project
- osmdata: Pulls vector data - different beast
- basemapR: active project, not on CRAN
- ggspatial: active project, on CRAN

Interestingly, OpenStreetMap, basemaps, and ggspatial make crappy looking maps, fuzzy
and not pleasing - cluttered with odd stuff. The basemapR map is much more
aesthetically pleasing.

I don't understand what OpenStreetMap is actually doing when it "reprojects"
the basemap. And it seems to be broken. Without reprojecting, the map appears
to be in an X-Y system, but a strange one. I can reproject to a lat long
system and everything seems okay, but if I give it an X-Y system to reproject
to, it ends up in lat-long. At least according to the axis values. 
Apparently OpenStreetMap uses the raster package to do projections. The following
warning is in the raster::projectRaster docs, "User beware. Sadly, the PROJ.4 notation 
has been partly deprecated in the GDAL/PROJ library that is used by this function. 
You can still use it, but *only* with the the WGS84 datum. Other datums are silently 
ignored." which explains a lot. Which is a serious limitation. Many states and counties
in the US do not use WGS84, but use NAD83 - which is close, but leads to a different
set of EPSG codes, and is a trap for the unwary. I really hate "silently ignores". That
is aggressively user unfriendly.

Using osmdata is a lot more work, and the map is much plainer (unless you
expend significant effort adding and controlling features), but it does
make a pretty good looking map.

As far as I can tell, the only package that will allow for a projected basemap
(that is X-Y coordinates) is OpenStreetMap. Which is sad.

There is also quite a bit of disparity in the size of the map objects. 

```{r size table, echo-=FALSE, results='asis'}
Basemap_size <- tribble( ~Package, ~Size_KB,
                         "OpenStreetMap", 6600,
                         "basemaps", 4.7,
                         "basemapR", 4.4,
                         "ggspatial", 34.0)
knitr::kable(Basemap_size, caption="Sizes in KB for different map objects")

```


```{r basemaps, warning=FALSE, message=FALSE}

########  package: OpenStreetMap
# Produces an OpenStreetMap object
Basemap_1 <- OpenStreetMap::openmap(c(bbox[["ymin"]],
                                    bbox[["xmin"]]),
                                  c(bbox[["ymax"]],
                                    bbox[["xmax"]]),
                                  type="osm")

########  package: basemaps
# Produces a ggplot object
basemaps::set_defaults(map_service = "osm", map_type = "streets")
Basemap_2 <- basemaps::basemap_ggplot(ext=bbox)

########  package: basemapR
# Produces a ggplot object
Basemap_3 <- basemapR::base_map(bbox, basemap="mapnik", increase_zoom=2)

########  package: ggspatial
# Produces a ggplot object
Basemap_4 <- ggplot(df_sf) + ggspatial::annotation_map_tile(zoomin=-1) 

# ---------------------   Let's plot the maps, with some data if possible

#   Plot in projected coordinates, but be careful!
m1 <- OpenStreetMap::autoplot.OpenStreetMap(OpenStreetMap::openproj(Basemap_1,
                                      projection=localcrs)) +
  geom_point(data=as_tibble(sf::st_coordinates(df_xy)), aes(x=X, y=Y))
#   Plot in Lat Long (Scale coordinates to act like lat-long )
m2 <- OpenStreetMap::autoplot.OpenStreetMap(OpenStreetMap::openproj(Basemap_1),
                                      projection=googlecrs) +
  geom_point(data=df, aes(y=Lat, x=Lon))
  
m3 <- Basemap_2 +
  geom_sf(data=df_web)
  
#   This is the best looking one.
m4 <- df_sf %>% ggplot() +
  Basemap_3 +
  geom_sf()

m5 <- Basemap_4 +
    geom_sf(inherit.aes = FALSE) +
    theme_minimal()

#gridExtra::grid.arrange(m1, m2, m3, m4, m5, ncol=2)

m1
m2
m3
m4
m5

```

###  One more basemap, but this one built with vectors, not rasters

The data from the Open Street Maps can be downloaded as points, vectors, and polygons.
This allows a scale-free map of much higher resolution, but is not quite as nice,
unless a lot of effort is expended on the aesthetics, and is also quite large. Actually
the various vector layers can be quite large, but the final map is quite small, as can
be seen in the table below. 

For plotting the map in projected coordinates, we have to project the AOI as well. But we
can plot the map in projected coordinates which most of the raster-based basemaps do not
allow. So there are some clear advantages to using a vector map. Probably not what you want
for a quick and dirty, but if you plane to be working in the same area for some time, it is
probably worth spending the effort to tweak up a pretty vector-based map.

```{r size table, echo-=FALSE, results='asis'}
Basemap_size <- tribble( ~Package, ~Size_KB,
                         "Big Streets", 47.4,
                         "Medium Streets", 99.0,
                         "Rivers", 35.4,
                         "Lakes", 45.9,
                         "ggplot object", 5.7)
knitr::kable(Basemap_size, caption="Sizes in KB for different map objects")
```


```{r basemaps_2, warning=FALSE, message=FALSE}

###########   Now for something different, let's create a map with vectors
###########   by using osmdata 

osmdata::available_features()
osmdata::available_tags("highway")


#     pull out the "big streets"
big_streets <- 
  tmaptools::bb(bbox, output="matrix") %>% # turn bounding box into matrix
  osmdata::opq()%>% # Build query
  osmdata::add_osm_feature(key = "highway", 
                  value = c("motorway", 
                            "motorway_link" 
                            )) %>% # select the big roads
  osmdata::osmdata_sf() # turn into an sf file
  

#     pull out the "medium streets"
med_streets <- 
  tmaptools::bb(bbox, output="matrix") %>%  # turn bounding box into matrix
  osmdata::opq()%>%  #   Build query
  osmdata::add_osm_feature(key = "highway", 
                  value = c( "secondary_link",
                            "secondary")) %>%  #   Grab smaller roads
  osmdata::osmdata_sf() #   Make sf

#   Now get rivers
osmdata::available_tags("waterway")
osmdata::available_tags("water")

river <- tmaptools::bb(bbox, output="matrix") %>%
  osmdata::opq()%>%
  osmdata::add_osm_feature(key = "waterway", value = "river") %>%
  osmdata::osmdata_sf()  

lakes <- tmaptools::bb(bbox, output="matrix") %>%
  osmdata::opq()%>%
  osmdata::add_osm_feature(key = "water", value = c("reservoir",
                                                    "lake",
                                                    "basin",
                                                    "pond")) %>%
  osmdata::osmdata_sf() 

#   Now put it all together and make a plot

m6 <- ggplot() +
  geom_sf(data = med_streets$osm_lines,
          inherit.aes = FALSE,
          size = 0.4,
          color = "grey25") +
  geom_sf(data = big_streets$osm_lines,
          inherit.aes = FALSE,
          size = 0.4,
          color = "red") +
  geom_sf(data = river$osm_lines,
          inherit.aes = FALSE,
          size = 0.4,
          color = "blue") +
  geom_sf(data = lakes$osm_polygons,
          inherit.aes = FALSE,
          fill="steelblue",
          color = "steelblue") +
  geom_sf(data=df_sf) +
  #   coord_sf needs to follow all the geom_sf statements
  coord_sf(xlim = c(bbox[["xmin"]], bbox[["xmax"]]),
           ylim = c(bbox[["ymin"]], bbox[["ymax"]]),
           expand = FALSE,
           default_crs=googlecrs)  

m6

#   Convert to X-Y for a projected map

#  First convert bounding box (I need to make this cleaner, but this will do for now)

XYmin <- sf::st_transform(sf::st_sfc(sf::st_point(x=c(bbox[["xmin"]], bbox[["ymin"]])),
                                     crs=googlecrs), crs=localcrs)
XYmax <- sf::st_transform(sf::st_sfc(sf::st_point(x=c(bbox[["xmax"]], bbox[["ymax"]])),
                                     crs=googlecrs), crs=localcrs)

m7 <- ggplot(df_xy) +
  geom_sf(data = sf::st_transform(med_streets$osm_lines, crs=localcrs),
          inherit.aes = FALSE,
          size = 0.4,
          color = "grey25") +
  geom_sf(data = sf::st_transform(big_streets$osm_lines, crs=localcrs),
          inherit.aes = FALSE,
          size = 0.4,
          color = "red") +
  geom_sf(data = sf::st_transform(river$osm_lines, crs=localcrs),
          inherit.aes = FALSE,
          size = 0.4,
          color = "blue") +
  geom_sf(data = sf::st_transform(lakes$osm_polygons, crs=localcrs),
          inherit.aes = FALSE,
          fill="steelblue",
          color = "steelblue") +
  geom_sf(data=df_xy) + # This will post graticules in X-Y rather than Lat-Long
  # coord_sf must follow the geom_sf statements for the bounding box to be applied properly
  coord_sf(xlim = c(XYmin[[1]][1], XYmax[[1]][1]),
           ylim = c(XYmin[[1]][2], XYmax[[1]][2]),
           expand = FALSE,
           datum=localcrs,
           default_crs=localcrs)

m7

```

### Interactive maps

Now we will create basemaps with input points as interactive maps using both Leaflet and tmap.

I like Leaflet, but it does seem to me to be a bit limited. What it does, it does well 
and simply. I have foregone the default markers because I don't really like them, and so 
that this map is more comparable to the other maps.

Note that the basemap quality is quite high - the features and lettering are crisp and 
distinct - something that the static basemaps seem to struggle with. There is a plugin
for Leaflet that allows the use of projected data - but *only if the server uses that same
projection*. So, for the general case of projecting to a local system, it is pretty useless
unless you actually set up your own server for your area of interest.

```{r leaflet basemap}

leaflet::leaflet() %>% 
  leaflet::addTiles() %>% # OpenStreetMap by default
  leaflet::addCircleMarkers(data=df_sf, 
                   radius=2, 
                   color="black",
                   opacity=1,
                   fillOpacity = 1)

```

Finally let's take a look at tmap - which can do both static and interactive maps.

We can also transform the basemap to a local X-Y coordinate system, but the results are
not especially pleasing since the text labels get distorted by the transform.

```{r tmap basemap}

#   Set default basemap
tmap::tmap_options(basemaps="OpenStreetMap")

tmap::tmap_mode("view") # set mode to interactive plots

tmap::tm_shape(df_sf) + 
  tmap::tm_sf(col="black", size=0.5)

#  Note that you need to interactively pick which basemap to display

#  Now make a static map

tmap::tmap_mode("plot") # set mode to static plots

Basemap_5 <- tmaptools::read_osm(bbox, type="osm")

# bbox_sf <- sf::st_sfc(sf::st_multipoint(x=tmaptools::bb(bbox, output="matrix", 
#                                              current.projection = googlecrs)))
# sf::st_crs(bbox_sf) <- googlecrs

tmap::tm_shape(Basemap_5) +
    tmap::tm_rgb() +
tmap::tm_shape(df_sf) + 
  tmap::tm_sf(col="black", size=0.3)

#     And now for projected coordinates

Basemap_6 <- stars::st_transform_proj(Basemap_5, crs=localcrs)

tmap::tm_shape(Basemap_6) +
    tmap::tm_rgb() +
tmap::tm_shape(df_xy) + 
  tmap::tm_sf(col="black", size=0.3)


```


###   Density contours

We will ignore the actual point values and just look at the point density.
This is generally a good idea, just to get a feel for where the data is thin 
and where the ending results are likely to be more reliable. And this will be 
a good way to work through the mechanics of posting filled contours onto a
basemap.

Let's plot three ways, an interactive plot with Leaflet, and a static plot with
ggplot, and also use tmap.

For the static maps, I will use the basemaps generated above that looked the best.

To add a scalebar, there are two options: ggspatial or ggsn. 

References that were especially helpful :

https://swilke-geoscience.net/post/spatial_interpolation/
https://github.com/dkahle/ggmap
https://r-spatial.org/r/2018/10/25/ggplot2-sf.html
[eks](https://www.mvstat.net/mvksa/)

###       Measurement density

Let's make a quick plot of the measurement location density. Always nice to
get a feel for where the measurements are denser. My biggest issue with the 
density plot is that I don't know what the numbers mean. A density of 5 is
5 stations per what? Not at all clear. Of course, it is fairly bogus anyway
since I have done everything in Lat-Long, and not in X-Y.

One advantage of using the eks density estimate, is that it is clearer what the 
output means. The 20% contour means "20% of the measurements lie inside this contour".
The documentation for eks takes issue with how stat_density_2d does its calculation,
I don't know who is right, but for this dataset they are quite similar results.

I have also added a scalebar to the maps, which is a good idea. I like the scalebar from
ggspatial the best, but the scalebar made with ggsn is generally easier to get to work
and less fussy.

Note that I am mixing and matching things from ggspatial with other things, to get what I
like the best. This can cause issues, but a little patience can get it all to work. It is
and example of how some more consolidation and standards in this realm would be really
helpful.

```{r static density maps}

##########################################################
#   Density map
##########################################################

#   Lay down basemap
m1 <- 
ggplot(df_sf) +
  #   this is the best looking basemap
  Basemap_3 +
  #   Add points
  geom_sf(inherit.aes = FALSE) +
  #   Create filled density "contours" - the as.numeric converts from factor
  #   for the scale_fill_gradient command.
  stat_density_2d_filled(data=df, 
                         alpha = 0.4, 
                         n=50,
                         contour_var="density",
                         aes(x=Lon, y=Lat, 
                             fill=as.numeric(..level..))) +
  #   Add actual contour lines
  stat_density_2d(data=df, 
                  alpha = 0.8, 
                  n=50,
                  contour=TRUE,
                  contour_var="density",
                  aes(x=Lon, y=Lat )) +
  #   Twiddle the color scale
  scale_fill_gradient2("Rainfall Station\ndensity", 
                       low = "white", 
                       mid = "yellow", 
                       high = "red", 
                       limits=c(0,8),
                       midpoint = 4) +
  #   Add a scale bar
 ggspatial::annotation_scale(data=df_sf, aes(unit_category="imperial", style="ticks"),
    location="br", width_hint=0.2, bar_cols=1) +
#  ggsn::scalebar(df_sf, dist = 2, dist_unit = "mi", location="bottomleft",
#             transform = TRUE, model = "WGS84") +
  #   Add title
  ggtitle("Density of Rainfall Measurements") +
  labs(subtitle="Density using stat_density_2d") +
  coord_sf(crs=googlecrs) # required 


#######  Just for fun let's utilize the eks package for density estimates

Sta_den <- eks::st_kde(df_sf) # calculate density

#   Lay down basemap
m2 <- 
  ggplot() +
  #   this is the best looking basemap
  Basemap_3 +
  #   Add points
  geom_sf(data=df_sf) +
  #   Create filled density "contours" 
  geom_sf(data=eks::st_get_contour(Sta_den,
                                   cont=c(20,40,60,80)),   
          aes(fill=eks::label_percent(contlabel)), alpha=0.4) +
  colorspace::scale_fill_discrete_sequential(name = "Density Percentile") +

  #   Add a scale bar
  ggspatial::annotation_scale(data=df_sf, aes(unit_category="imperial", style="ticks"),
    location="br", width_hint=0.2, bar_cols=1) +
 # ggsn::scalebar(df_sf, dist = 2, dist_unit = "mi", location="bottomleft",
  #           transform = TRUE, model = "WGS84") +
  #   Add title
  ggtitle("Density of Rainfall Measurements") +
  labs(subtitle="Density using EKS") +
  coord_sf(crs=googlecrs) # required 


m1
m2

```


Now for Leaflet maps

```{r leaflet density}


############    Now let's do it in Leaflet

leaflet() %>% 
  addTiles() %>% # OpenStreetMap by default
  addCircleMarkers(data=df_sf, 
                   radius=2, 
                   color="black",
                   opacity=1,
                   fillOpacity = 1) %>% 
  #   This is *not* the same as stat_density, and is scale dependent, 
  #   which sucks.
  addHeatmap(data=df, group="heat", max=.6, blur = 60,
             radius=30)
  
#   VERY conveniently, eks can generate an sf file of contour lines
contours <- eks::st_get_contour(Sta_den, cont=c(20,40,60,80)) %>% 
  mutate(value=as.numeric(levels(contlabel)))

pal_fun <- colorQuantile("YlOrRd", NULL, n = 5)

p_popup <- paste("Density", as.numeric(levels(contours$contlabel)), "%")

leaflet(contours) %>% 
  addTiles() %>% # OpenStreetMap by default
  addCircleMarkers(data=df_sf, 
                   radius=2, 
                   color="black",
                   opacity=1,
                   fillOpacity = 1)  %>% 
  addPolygons(fillColor = ~pal_fun(as.numeric(contlabel)),
              popup = p_popup)

```

Okay, now let's see what it takes to make a similar map in tmap.

I should note that one issue I have with tmap is that it will silently ignore errors
far too often. I misspelled options, color palettes, and other items and the items were silently
ignored, which was incredibly frustrating. That makes it much harder to use than it should be.

```{r density map in tmap}


tmap::tmap_mode("view") # set mode to interactive plots

tmap::tm_shape(df_sf) + 
    tmap::tm_sf(col="black", size=0.5) +
  tmap::tm_shape(contours) +
    tmap::tm_polygons(col="value",
                      palette="Blues",
                      alpha=0.5 )

#  Note that you need to interactively pick which basemap to display

#  Now make a static map

tmap::tmap_mode("plot") # set mode to static plots

Basemap_5 <- tmaptools::read_osm(bbox, type="osm")

tmap::tm_shape(Basemap_5) +
    tmap::tm_rgb() +
  tmap::tm_shape(df_sf) + 
    tmap::tm_sf(col="black", size=0.3) +
  tmap::tm_shape(contours) +
    tmap::tm_polygons(col="contlabel",
                      title="Density %",
                      labels=c("80%", "60%", "40%", "20%"),
                      palette="Blues",
                      alpha=0.5 ) +
  tmap::tm_layout(legend.position = c("right", "top"),
                  legend.frame=TRUE)

#     And now for projected coordinates

Basemap_6 <- stars::st_transform_proj(Basemap_5, crs=localcrs)

tmap::tm_shape(Basemap_6) +
    tmap::tm_rgb() +
tmap::tm_shape(df_xy) + 
  tmap::tm_sf(col="black", size=0.3)+
  tmap::tm_shape(sf::st_transform(contours, crs=localcrs)) +
    tmap::tm_polygons(col="contlabel",
                      title="Density %",
                      labels=c("80%", "60%", "40%", "20%"),
                      palette="Blues",
                      alpha=0.5 ) +
  tmap::tm_layout(legend.position = c("right", "top"),
                  legend.frame=TRUE)

```


##        Contours by value

This is complicated. Because we want a basemap underneath, the basemap is in 
EPSG:3857, the Spherical Pseudo-Mercator projection, and is
basically just an image.

But gridding schemes want to be in X-Y.

So let's set up an X-Y grid, interpolate to the X-Y locations, and
then put those back on the lat-long grid.

One source of frustration here is that I would prefer to stick with just one "raster"
package, but I don't see an easy way to not pop back and forth between terra and stars.
Stars is much better integrated with sf, making those transitions smooth and painless,
but terra has better smoothing options.

Notes on making a grid. I have had many long, and sometimes heated discussions with
colleagues on what a grid spacing should be. There is no right answer. The spacing should be
of the same order of magnitude as the average spacing between your data points, but if that
spacing is quite irregular with clusters and sparse areas, that becomes problematic. If you
choose a spacing that honors the clustered data, then you may suffer from artifacts in the
sparse data areas. If you honor the sparse spacing, then you will lose resolution in the densely
populated areas. Ultimately it is a balancing act and needs to be looked at in light of the
objectives of the map. Forcing sparse areas to not contour is one solution, or adding 
pseudo-data to the sparse areas to control the interpolation is another.


```{r Rainfall Inverse weighted map}

  # grid <- with(df_xy, interp::interp(X, Y, Rain))
  # griddf <- subset(data.frame(x = rep(grid$x, nrow(grid$z)),
  #                             y = rep(grid$y, each = ncol(grid$z)),
  #                             z = as.numeric(grid$z)),
  #                  !is.na(z))

#   First we create a grid to interpolate to - in XY coordinates, not lat long.  

bbox_xy = bbox %>%
  sf::st_as_sfc() %>%
  sf::st_transform(crs = localcrs) %>%
  sf::st_bbox()
  
#    Three ways to create a grid definition - note that the first gives corner coordinates.

grd_template <- expand.grid(
  X = seq(from = bbox_xy["xmin"], to = bbox_xy["xmax"], by = 1000),
  Y = seq(from = bbox_xy["ymin"], to = bbox_xy["ymax"], by = 1000) # 1000 m resolution
)

grd_template2 <- sf::st_make_grid(x=bbox_xy,
                                  what="corners",
                                  cellsize=1000,
                                  crs=localcrs
                                  )

grd_template3 <- terra::rast(xmin=bbox_xy["xmin"]-1000, xmax=bbox_xy["xmax"]+2000,
                             ymin=bbox_xy["ymin"]-1000, ymax=bbox_xy["ymax"]+2000,
                             resolution=2000,
                             crs=localcrs,
                             vals=1,
                             names="Foo")

ggplot() +
  geom_point(data=grd_template, aes(x=X, y=Y)) +
  geom_sf(data=grd_template2, shape="+", color="red", size=5) +
  geom_sf(data=sf::st_as_sf(terra::as.points(grd_template3)), shape="o", size=6, color="green")

#   I prefer the second method, since it creates a geographic object with an attached CRS,
#   which is important. Keeping consistent coordinates is crucial.

#     Create interpolator and interpolate to grid

#--------------------------------------------------------------
#          Inverse Distance Weighting
#--------------------------------------------------------------
fit_IDW <- gstat::gstat( 
  formula = Rain ~ 1,
  data = df_xy, 
  #nmax = 10, nmin = 3,
  set = list(idp = 2) # inverse distance power
)

#   Use predict to apply the model fit to the grid

interp_IDW <- predict(fit_IDW, grd_template2)

#   Quick sanity check, and can use to adjust the distance power
#   Looks pretty good - most input points look close to the output
#   grid points, with some notable exceptions. The red point to the north
#   is probably bad data. Easier to judge from areal displays.
ggplot() +
  geom_sf(data=interp_IDW, aes(color=var1.pred), size=5) +
  geom_sf(data=df_xy, aes(color=Rain), size=5) +
  scale_color_gradientn(colors=rainbow(5)) 

#   Let's make some contours

#   Convert to a stars object so we can use the contouring in stars
interp_IDW_stars <- stars::st_rasterize(interp_IDW %>% dplyr::select(value=var1.pred, geometry))
#   Make some pretty breaks for contour intervals based on the data
brks <- classInt::classIntervals(pretty(n=10, x=as.vector(interp_IDW_stars[[1]])), n=8)
#   Create contour lines
Contours_IDW <- stars::st_contour(interp_IDW_stars, contour_lines=TRUE, breaks=brks$brks)
#   Plot to see what it all looks like
ggplot() +
  geom_sf(data=interp_IDW, aes(color=var1.pred), size=5) +
  geom_sf(data=df_xy, aes(color=Rain), size=5) +
  scale_color_gradientn(colors=rainbow(5)) +
  geom_sf(data=Contours_IDW, color="red") 
  
#   Hmmm.... could use some smoothing
#   But stars does not have focal operations, so we go to terra?

foo_terra <- terra::rast(interp_IDW_stars) 
foo_sm <- terra::focal(terra::focal(foo_terra, w=5, fun=median), w=7, fun=mean)
brks <- classInt::classIntervals(pretty(n=10, x=na.omit(as.vector(foo_sm[[1]]))), n=6)
#   Create contours again
Contours_sm <- stars::st_contour(stars::st_as_stars(foo_sm), contour_lines=FALSE, breaks=brks$brks)
#  One more step - let's smooth the contours
Contours_sm2 <- smoothr::smooth(Contours_sm, method="ksmooth", smoothness=2)

#   and our final plot in X-Y space
ggplot() +
  geom_sf(data=interp_IDW, aes(color=var1.pred), size=5) +
  geom_sf(data=df_xy, aes(color=Rain), size=5) +
  scale_color_gradientn(colors=rainbow(5)) +
  geom_sf(data=Contours_IDW, color="red") +
  geom_sf(data=Contours_sm, color="black", alpha=0.4) +
  geom_sf(data=Contours_sm, color="black", alpha=0.4) +
  geom_sf(data=Contours_sm2, color="blue", aes(fill=focal_mean), alpha=0.4) 

#   Now lets transform the contours to lat-long space and plot on the basemap

Contours_LL <- sf::st_transform(Contours_sm, crs=googlecrs) 

ggplot() +
  #   this is the best looking basemap
  Basemap_3 +
  #   Add points
  geom_sf(data=df_sf) +
  #   Create filled density "contours" 
  geom_sf(data=Contours_LL, 
          aes(fill=focal_mean), alpha=0.4) +
  colorspace::scale_fill_discrete_sequential(name = "Inches Rain") +

  #   Add a scale bar
  ggspatial::annotation_scale(data=df_sf, aes(unit_category="imperial", style="ticks"),
    location="br", width_hint=0.2, bar_cols=1) +
  #   Add title
  ggtitle("Rainfall Measurements") +
  coord_sf(crs=googlecrs) # required 

#   Finally, let's do some checks on how well this procedure did.

# Leave-one-out validation routine
npts <- length(sf::st_geometry(df_xy)) # number of points in sf object
IDW.out <- vector(length = npts)
for (i in 1:npts) {
  IDW.out[i] <- gstat::idw(formula=Rain ~ 1, 
                           locations=df_xy[-i,], 
                           newdata=df_xy[i,], 
                           #nmax = 10, nmin = 3,
                           idp=2.0)$var1.pred
}

bind_cols(sf::st_drop_geometry(df_xy), as_tibble(IDW.out)) %>% 
  rename(Observed=Rain, Predicted=value ) %>% 
  ggplot(aes(x=Observed, y=Predicted)) + 
    geom_point() +
    geom_smooth(method='lm') +
    geom_abline(intercept=0, slope=1, color="red", linetype="dashed") +
    labs(title="Leave-one-out Validation",
         x="Observed (inches)",
         y="Predicted (inches)")

# Compute RMSE
sqrt( sum((IDW.out - df_xy$Rain)^2) / npts)

```

```{r Kriging}

#   Struggled a lot to get examples to work, so I went my own way
#   It is important in Kriging to remove any low frequency trend. This is typically
#   done by fitting a low-order polynomial surface to the data and subtracting that
#   off before proceeding. Then at the end, you add it back. 

#   Let's look at 1st and 2nd order fits

df_xy_df <- bind_cols(sf::st_drop_geometry(df_xy), sf::st_coordinates(df_xy)) # make a tibble

# Define the 1st order polynomial equation
f.1 <- as.formula(Rain ~ X + Y) 

# Run the regression model
lm.1 <- lm( f.1, data=df_xy_df)

#   Use predict to apply the model fit to the grid
#     This re-attaches X-Y coordinates to the predicted values so they can be made into a grid

Poly_fit.1 <- sf::st_as_sf(bind_cols(grd_template,data.frame(var1.pred=predict(lm.1, grd_template))), crs=localcrs, coords=c("X", "Y"))

#   Convert to a stars object 
Poly_fit_star.1 <- stars::st_rasterize(Poly_fit.1 %>% dplyr::select(value=var1.pred, geometry))

ggplot() +
  stars::geom_stars(data=Poly_fit_star.1) +
  geom_sf(data=df_xy, color="black", size=5) +
  scale_fill_gradientn(colors=rainbow(5)) 

# Now let's do a 2nd order polynomial       

##################################################################################

# Define the 1st order polynomial equation
f.1 <- as.formula(Rain ~ X + Y) 

# Compute the sample variogram; note that the f.1 trend model is one of the
# parameters passed to variogram(). This tells the function to create the 
# variogram on the de-trended data.
df_xy_df <- bind_cols(sf::st_drop_geometry(df_xy), sf::st_coordinates(df_xy)) # make a tibble
var.smpl <- gstat::variogram(Rain ~ 1, 
                             df_xy)
                             as(df_xy, "Spatial")) # switch from {sf} to {sp}
                             #cloud = FALSE, cutoff=1000000, width=89900)

# Compute the variogram model by passing the nugget, sill and range values
# to fit.variogram() via the vgm() function.
dat.fit  <- fit.variogram(var.smpl, fit.ranges = FALSE, fit.sills = FALSE,
                          vgm(psill=14, model="Sph", range=590000, nugget=0))

# The following plot allows us to assess the fit
plot(var.smpl, dat.fit, xlim=c(0,1000000))

```




```{r Bicubic splines}

```



```{r Thin Plate}

```




```{r delete me eventually}



##########################################################
#   Heat map by value
##########################################################

#   This is more complex. We first have to create a grid, then
#   interpolate to that grid. Then we can contour the grid.

####   Create a grid to interpolate to

df_grid <- df_sf_pan %>% 
  st_bbox() %>% 
  st_as_sfc() %>% 
  st_make_grid(
  cellsize = c(.01, .01), # degrees
  what = "centers"
  ) %>%
  st_as_sf() %>%
  cbind(., st_coordinates(.)) %>% 
  st_drop_geometry() %>% 
  mutate(Z = 0)

#   Also create a raster of the grid for some of the algorithms

df_grid_raster <- df_grid %>% 
  raster::rasterFromXYZ(
     crs = googlecrs
  )

#   Now fit various models to the data

#   -------- Nearest Neighbor
fit_NN <- gstat::gstat( # using package {gstat} 
  formula = Num_panels ~ 1,    
  data = as(df_sf_pan, "Spatial"), # using {sf} and converting to {sp}
  nmax = 10, nmin = 3 # Number of neighboring observations used for the fit
)

# -------- Inverse Distance Weighting
fit_IDW <- gstat::gstat( # The setup here is quite similar to NN
  formula = Num_panels ~ 1,
  data = as(df_sf_pan, "Spatial"), # using {sf} and converting to {sp}
  nmax = 10, nmin = 3,
  set = list(idp = 0.5) # inverse distance power
)

interp_IDW <- raster::interpolate(df_grid_raster, fit_IDW)

# -------- Thin Plate Spline Regression
fit_TPS <- fields::Tps( # using {fields}
  x = as.matrix(df_panels[, c("Lon", "Lat")]), # accepts points but expects them as matrix
  Y = df_panels$Num_panels,  # the dependent variable
  miles = FALSE     # EPSG 25833 is based in meters
)

# --------- Generalized Additive Model
#fit_GAM <- mgcv::gam( # using {mgcv}
#  Num_panels ~ s(Lon, Lat),      # here come our X/Y/Z data - straightforward enough
#  data = df_panels      # specify in which object the data is stored
#)

# --------- Automatized Kriging  
fit_KRIG <- automap::autoKrige(      # using {automap}
  formula = Num_panels ~ 1,         # The interface is similar to {gstat} but
  input_data = as(df_xy_pan, "Spatial") # {automap} makes a lot of assumptions for you
) %>% 
  .$krige_output %>%  # the function returns a complex object with lot's of metainfo
  as.data.frame() %>% # we keep only the data we are interested in
  dplyr::select(X = x1, Y = x2, Z = var1.pred) 
interp_KRIG <- raster::rasterFromXYZ(fit_KRIG, crs = googlecrs)
# Convert grid to a lat-long tibble of points
df_krig <- raster::rasterToPoints(interp_KRIG) %>% 
  as_tibble() %>% 
  st_as_sf(., coords=c("x", "y"), crs=26915, agr = "identity") %>% 
  st_transform(., crs=googlecrs) %>% 
     mutate(Lon = unlist(map(geometry,1)),
            Lat = unlist(map(geometry,2))) %>% 
  st_drop_geometry()
#   Lat long raster
df_grid_raster_sp <- sp::SpatialPoints(df_grid_raster)
fitmax <- gstat::gstat(formula = Z ~ 1, data = df_krig, nmax = 4, set = list(idp = .5))
maxint <- raster::interpolate(object=df_grid_raster_sp, model=fitmax)

wgs84 = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
df_krig_ll = raster::projectRaster(from=df_krig, to=df_grid_raster,
                                   crs = googlecrs, method = "bilinear")
#df_krig_ll <- raster::projectRaster(interp_KRIG, crs = googlecrs)
#df_krig_ll <- raster::rasterToPolygons(df_krig_ll)
#' Transform raster as data.frame to be later used with ggplot
#' Modified from rasterVis::gplot
#'
#' @param x A Raster* object
#' @param maxpixels Maximum number of pixels to use
#'
#' @details rasterVis::gplot is nice to plot a raster in a ggplot but
#' if you want to plot different rasters on the same plot, you are stuck.
#' If you want to add other information or transform your raster as a
#' category raster, you can not do it. With `SDMSelect::gplot_data`, you retrieve your
#' raster as a data.frame that can be modified as wanted using `dplyr` and
#' then plot in `ggplot` using `geom_tile`.
#' If Raster has levels, they will be joined to the final tibble.
#'
#' @export

gplot_data <- function(x, maxpixels = 50000)  {
  x <- raster::sampleRegular(x, maxpixels, asRaster = TRUE)
  coords <- raster::xyFromCell(x, seq_len(raster::ncell(x)))
  ## Extract values
  dat <- utils::stack(as.data.frame(raster::getValues(x)))
  names(dat) <- c('value', 'variable')

  dat <- dplyr::as.tbl(data.frame(coords, dat))

  if (!is.null(levels(x))) {
    dat <- dplyr::left_join(dat, levels(x)[[1]],
                            by = c("value" = "ID"))
  }
  dat
}

#   Lay down basemap
OpenStreetMap::autoplot.OpenStreetMap(Basemap2) +
#  ggplot()+
  #geom_polygon(data=df_krig_ll, aes(fill=rep(df_krig_ll$data, each = 5)), alpha=0.8) 
  #geom_tile(data=gplot_data(interp_KRIG), aes(x,y,fill=value), alpha=0.5)
  geom_tile(data=gplot_data(interp_IDW), aes(x,y,fill=value), alpha=0.5)+
  viridis::scale_fill_viridis() +
  #   Add actual contour lines
  geom_contour(data=gplot_data(interp_IDW), 
                   aes(x,y, z=value),
                   alpha = 0.8, 
                   #binwidth=1.60934,
                   binwidth=2
   )
  #   Twiddle the color scale
  scale_fill_gradient2("Solar Panels\nper sq-mi", 
                       low = "white", 
                       mid = "yellow", 
                       high = "red", 
                       #limits=c(2,50),
                       #midpoint =  5
                       ) +
  #   Add a scale bar
  scalebar(df_sf, dist = 2, dist_unit = "mi", location="bottomleft",
             transform = TRUE, model = "WGS84") +
  #   Add title
  ggtitle("Number of Solar Panels per sq-mi") +
  #   Remove lat/long tics and labels as unnecessary
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank()
        ) +
  labs(x="", y="")


# --------------  function for plotting a raster

plot_raster <- function(raster) {
  df <- raster::rasterToPoints(raster) %>% as_tibble()
  colnames(df) <- c("X", "Y", "Z")
  
  ggplot(df, aes(x=X, y=Y, z=Z, fill=Z)) +
  #OpenStreetMap::autoplot.OpenStreetMap(Basemap2) +
    geom_point(data=df, aes(x=X, y=Y)) +
    geom_raster(data=df, aes(x=X, y=Y, z=Z, fill=Z)) #+
    #scale_fill_viridis(option="C")
}

plot_raster(interp_KRIG)

##################################   stopped here
#   Lay down basemap
#OpenStreetMap::autoplot.OpenStreetMap(Basemap2) +
  #   Add points
ggplot(data=df_panels)+
  geom_point(data=df_panels, aes(x=Lon, y=Lat)) +
  #   Create filled density "contours" - the as.numeric converts from factor for
  #   the scale_fill_gradient command.
  # geom_contour_filled(data=df_panels, 
  #                     alpha = 0.4, 
  #                     #binwidth=1.60934, # native units are kilometers, 
  #                     #                   so convert to miles
  #                     aes(x=Lon, y=Lat, z=Num_panels)) +
  #   Add actual contour lines
  geom_contour(data=df_panels, 
               alpha = 0.8, 
               #binwidth=1.60934,
               aes(x=Lon, y=Lat, z=Num_panels ))# +
  #   Twiddle the color scale
  scale_fill_gradient2("Solar Panels\nper sq-mi", 
                       low = "white", 
                       mid = "yellow", 
                       high = "red", 
                       limits=c(2,12),
                       midpoint =  5) +
  #   Add a scale bar
  scalebar(df_sf, dist = 2, dist_unit = "mi", location="bottomleft",
             transform = TRUE, model = "WGS84") +
  #   Add title
  ggtitle("Number of Solar Panels per sq-mi") +
  #   Remove lat/long tics and labels as unnecessary
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.x = element_blank(),
        axis.ticks.y = element_blank()
        ) +
  labs(x="", y="")

  
ggplot(data=df_panels, aes(Lon, Lat, z=Num_panels, color=Num_panels))+
  scale_color_gradientn(colors = c("blue", "yellow", "red")) +
  geom_point() +
  geom_contour()
```


```{r cleaner grid and plot}
coord_sf(xlim = st_coordinates(bbox_new)[c(1,2),1], # min & max of x values
           ylim = st_coordinates(bbox_new)[c(2,3),2]) + # min & max of y values
  
  coord_sf(
    xlim = c(bbox["xmin"], bbox["xmax"]),
    ylim = c(bbox["ymin"], bbox["ymax"]), crs = 4326
  )
#   Create a bounding box and use for basemap

bbox <- sf::st_bbox(df_sf)
Basemap <- OpenStreetMap::openmap(c(bbox$ymin[[1]],
                                    bbox$xmin[[1]]),
                                  c(bbox$ymax[[1]],
                                    bbox$xmax[[1]]),
                                  type="osm")
Basemap2 <- OpenStreetMap::openproj(Basemap)
OpenStreetMap::autoplot.OpenStreetMap(Basemap2)

#   Create a lat long grid

####   Create a grid to interpolate to

df_grid <- df_sf_pan %>% 
  st_bbox() %>% 
  st_as_sfc() %>% 
  st_make_grid(
  cellsize = c(.01, .01), # degrees
  what = "centers"
  ) %>%
  st_as_sf() %>%
  cbind(., st_coordinates(.)) %>% 
  st_drop_geometry() %>% 
  mutate(Z = 0)

#   Also create a raster of the grid for some of the algorithms

df_grid_raster <- df_grid %>% 
  raster::rasterFromXYZ(
     crs = googlecrs
  )

# -------- Inverse Distance Weighting
fit_IDW <- gstat::gstat( # The setup here is quite similar to NN
  formula = Num_panels ~ 1,
  data = as(df_sf_pan, "Spatial"), # using {sf} and converting to {sp}
  nmax = 10, nmin = 2,
  set = list(idp = 0.5) # inverse distance power
)

#   Apply model to grid to create predicted points
interp_IDW <- raster::interpolate(df_grid_raster, fit_IDW)

#   Smooth the result for aesthetics
interp_IDW_sm <- raster::focal(interp_IDW, w=matrix(1, 3, 3), mean, pad=TRUE)

#   Lay down basemap
OpenStreetMap::autoplot.OpenStreetMap(Basemap2) +
  geom_tile(data=gplot_data(interp_IDW_sm), aes(x,y,fill=value), alpha=0.3)+
  viridis::scale_fill_viridis() +
  #   Add actual contour lines
  geom_contour(data=gplot_data(interp_IDW_sm), 
                   aes(x,y, z=value),
                   alpha = 0.8, 
                   binwidth=3) +
  geom_point(data=df_panels, aes(x=Lon, y=Lat, color=Num_panels)) 
  
  
  
```





